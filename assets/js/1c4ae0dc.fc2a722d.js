"use strict";(self.webpackChunkdora_rs_github_io=self.webpackChunkdora_rs_github_io||[]).push([[8902],{3321:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var r=t(74848),a=t(28453);const s={authors:"haixuan",title:"Rust-Python FFI",description:"Rust-Python FFI."},i=void 0,o={permalink:"/blog/rust-python",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/rust-python.md",source:"@site/blog/rust-python.md",title:"Rust-Python FFI",description:"Rust-Python FFI.",date:"2024-11-30T08:25:27.000Z",tags:[],readingTime:10.8,hasTruncateMarker:!1,authors:[{name:"Haixuan Xavier Tao",title:"Maintainer of dora-rs",url:"https://github.com/haixuantao",imageURL:"https://github.com/haixuantao.png",key:"haixuan"}],frontMatter:{authors:"haixuan",title:"Rust-Python FFI",description:"Rust-Python FFI."},unlisted:!1},l={authorsImageUrls:[void 0]},c=[{value:"Foreign Function Interface",id:"foreign-function-interface",level:2},{value:"Interfacing Arrays",id:"interfacing-arrays",level:2},{value:"Implementation 1: Default",id:"implementation-1-default",level:3},{value:"&gt; Calling <code>create_list</code> for a very large list like: <code>value = [1] * 100_000_000</code>  is going to return in <strong>2.27s</strong> \ud83d\ude9c",id:"-calling-create_list-for-a-very-large-list-like-value--1--100_000_000--is-going-to-return-in-227s-tractor",level:4},{value:"Implementation 2: PyBytes",id:"implementation-2-pybytes",level:3},{value:"&gt; For the same list input, <code>create_list_bytes</code> returns in <strong>78 milliseconds</strong>. That&#39;s <strong>30x</strong> better \ud83d\udc0e",id:"-for-the-same-list-input-create_list_bytes-returns-in-78-milliseconds-thats-30x-better-racehorse",level:4},{value:"Implementation 3: Apache Arrow",id:"implementation-3-apache-arrow",level:3},{value:"&gt; Same list returns in <strong>33 milliseconds</strong> . That&#39;s <strong>2x</strong> better than <code>PyBytes</code> \ud83d\udc0e\ud83d\udc0e",id:"-same-list-returns-in-33-milliseconds--thats-2x-better-than-pybytes-racehorseracehorse",level:4},{value:"Debugging",id:"debugging",level:2},{value:"<code>.unwrap()</code>",id:"unwrap",level:3},{value:"&gt; Example error:",id:"-example-error",level:4},{value:"eyre",id:"eyre",level:3},{value:"&gt; Same error as above but with <code>eyre</code> which gives a better looking error message:",id:"-same-error-as-above-but-with-eyre-which-gives-a-better-looking-error-message",level:4},{value:"Python traceback with <code>eyre</code>",id:"python-traceback-with-eyre",level:3},{value:"&gt; Example error with no custom traceback:",id:"-example-error-with-no-custom-traceback",level:4},{value:"&gt; Better errors with custom traceback:",id:"-better-errors-with-custom-traceback",level:4},{value:"Memory management",id:"memory-management",level:2},{value:"&gt; Calling this function will consume 440MB of memory. \ud83d\udc4e",id:"-calling-this-function-will-consume-440mb-of-memory--1",level:4},{value:"&gt; Calling this function will consume 80MB of memory. :thumbsup:",id:"-calling-this-function-will-consume-80mb-of-memory-thumbsup",level:4},{value:"Race condition",id:"race-condition",level:2},{value:"&gt; This threaded print was printed after 10.0s. \ud83d\ude22",id:"-this-threaded-print-was-printed-after-100s-cry",level:4},{value:"&gt; &quot;1&quot; was printed after 32\xb5s and &quot;2&quot; was printed after 80\xb5s, so there was no race condition. \ud83d\ude04",id:"-1-was-printed-after-32\xb5s-and-2-was-printed-after-80\xb5s-so-there-was-no-race-condition-smile",level:4},{value:"Tracing",id:"tracing",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Writing a rust library that is usable in multiple languages is not easy..."}),"\n",(0,r.jsxs)(n.p,{children:["This blogpost recollects things I have encountered while building ",(0,r.jsx)(n.a,{href:"https://github.com/webonnx/wonnx",children:"wonnx"})," and ",(0,r.jsx)(n.a,{href:"https://github.com/dora-rs/dora",children:"dora-rs"}),". I am going to use Rust-Python FFI through ",(0,r.jsx)(n.code,{children:"pyo3"})," as an example. You can then extrapolate those issues to other languages FFI."]}),"\n",(0,r.jsx)(n.h2,{id:"foreign-function-interface",children:"Foreign Function Interface"}),"\n",(0,r.jsx)(n.p,{children:"A foreign function interface (FFI) is an interface used to share data from different languages."}),"\n",(0,r.jsxs)(n.p,{children:["By default, python might not know what a Rust ",(0,r.jsx)(n.code,{children:"u16"})," is, so an interface is needed to make the two languages communicate."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://hackmd.io/_uploads/S1qiK8hRh.png",alt:""})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Image from ",(0,r.jsx)(n.a,{href:"https://hacks.mozilla.org/2019/08/webassembly-interface-types/",children:"WebAssembly Interface Types: Interoperate with All the Things!"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Building interfaces is not easy. Most of the time, we have to use the C-ABI to build our FFI as it is the common denominator between languages."}),"\n",(0,r.jsx)(n.p,{children:"Thankfully, there are FFI libraries that create interfaces for us and we can just focus on the important stuff such as the logic, algorithm, and so on."}),"\n",(0,r.jsx)(n.p,{children:"However, those FFI libraries might have limitations. This is what we're going to discuss."}),"\n",(0,r.jsxs)(n.p,{children:["One example of such FFI library is ",(0,r.jsx)(n.a,{href:"https://github.com/PyO3/pyo3",children:(0,r.jsx)(n.code,{children:"pyo3"})}),". ",(0,r.jsx)(n.a,{href:"https://github.com/PyO3/pyo3",children:(0,r.jsx)(n.code,{children:"pyo3"})})," is one of the most used Rust-Python binding and creates FFIs for you. All we have to do is wrap our function with a ",(0,r.jsx)(n.code,{children:"#[pyfunction]"})," and that will make it usable in Python."]}),"\n",(0,r.jsx)(n.h2,{id:"interfacing-arrays",children:"Interfacing Arrays"}),"\n",(0,r.jsxs)(n.p,{children:["In this blog post, I'm going to build a toy Rust-Python project with ",(0,r.jsx)(n.code,{children:"pyo3"})," to illustrate the issues I have faced."]}),"\n",(0,r.jsxs)(n.p,{children:["You can try this blogpost at home by forking the ",(0,r.jsx)(n.a,{href:"https://github.com/haixuanTao/blogpost_ffi",children:"blogpost repository"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"If you want to start from scratch, you can create a new project with:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"mkdir blogpost_ffi\nmaturin init # pyo3\n"})}),"\n",(0,r.jsx)(n.p,{children:"The default project will looks like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use pyo3::prelude::*;\n\n/// Formats the sum of two numbers as string.\n#[pyfunction]\nfn sum_as_string(a: usize, b: usize) -> PyResult<String> {\n    Ok((a + b).to_string())\n}\n\n/// A Python module implemented in Rust. The name of this function must match\n/// the `lib.name` setting in the `Cargo.toml`, else Python will not be able to\n/// import the module.\n#[pymodule]\nfn string_sum(_py: Python<'_>, m: &PyModule) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(sum_as_string, m)?)?;\n    Ok(())\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"We can call the function as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'maturin develop\npython -c "import blogpost_ffi; print(blogpost_ffi.sum_as_string(1,1))"\n# Return: "2" \n'})}),"\n",(0,r.jsxs)(n.p,{children:["In the above example, ",(0,r.jsx)(n.code,{children:"pyo3"})," is going to create FFIs to make Python integer interpretable as a Rust ",(0,r.jsx)(n.code,{children:"usize"})," without additional work."]}),"\n",(0,r.jsx)(n.p,{children:"However, automatically interpreted types might not be the most optimized implementation."}),"\n",(0,r.jsx)(n.h3,{id:"implementation-1-default",children:"Implementation 1: Default"}),"\n",(0,r.jsx)(n.p,{children:"Let's imagine that, we want to play with arrays, we want to receive an array input and return an array output between Rust and Python.\nA default inplementation, would look like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[pyfunction]\nfn create_list(a: Vec<&PyAny>) -> PyResult<Vec<&PyAny>> {\n    Ok(a)\n}\n\n#[pymodule]\nfn blogpost_ffi(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(sum_as_string, m)?)?;\n    m.add_function(wrap_pyfunction!(create_list, m)?)?;\n    Ok(())\n}\n\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"-calling-create_list-for-a-very-large-list-like-value--1--100_000_000--is-going-to-return-in-227s-tractor",children:["> Calling ",(0,r.jsx)(n.code,{children:"create_list"})," for a very large list like: ",(0,r.jsx)(n.code,{children:"value = [1] * 100_000_000"}),"  is going to return in ",(0,r.jsx)(n.strong,{children:"2.27s"})," ","\ud83d\ude9c"]}),"\n",(0,r.jsx)(n.p,{children:"That's quite slow... The reason being is that this list is going to be interpret one element at a time in a loop. We can do better by trying to use all elements at the same time."}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Check ",(0,r.jsx)(n.a,{href:"https://github.com/haixuanTao/blogpost_ffi/blob/main/test_script.py",children:"test_script.py"})," for details on how the function is called."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"implementation-2-pybytes",children:"Implementation 2: PyBytes"}),"\n",(0,r.jsxs)(n.p,{children:["Let's imagine that our array is a C-contiguous array that can be represented as a ",(0,r.jsx)(n.a,{href:"https://docs.python.org/3/library/stdtypes.html?highlight=bytes#bytes",children:(0,r.jsx)(n.code,{children:"PyBytes"})}),". The code can be optimized by casting the inputs and output as a ",(0,r.jsx)(n.code,{children:"PyBytes"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[pyfunction]\nfn create_list_bytes<'a>(py: Python<'a>, a: &'a PyBytes) -> PyResult<&'a PyBytes> {\n    let s = a.as_bytes();\n\n    let output = PyBytes::new_with(py, s.len(), |bytes| {\n        bytes.copy_from_slice(s);\n        Ok(())\n    })?;\n    Ok(output)\n}\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"-for-the-same-list-input-create_list_bytes-returns-in-78-milliseconds-thats-30x-better-racehorse",children:["> For the same list input, ",(0,r.jsx)(n.code,{children:"create_list_bytes"})," returns in ",(0,r.jsx)(n.strong,{children:"78 milliseconds"}),". That's ",(0,r.jsx)(n.strong,{children:"30x"})," better ","\ud83d\udc0e"]}),"\n",(0,r.jsx)(n.p,{children:"The speedup comes from the possibility to copy the memory range instead of iterating each element and to read without copying."}),"\n",(0,r.jsx)(n.p,{children:"Now the issue is that:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"PyBytes"})," is only available in Python meaning that if we plan to have other languages, we will have to replicate this for each language."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"PyBytes"})," might also probably need to be reconverted into other useful types."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"PyBytes"})," needs a copy to be created."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["We can try to solve this with ",(0,r.jsx)(n.a,{href:"https://arrow.apache.org/",children:"Apache Arrow"}),"."]}),"\n",(0,r.jsxs)(n.h3,{id:"implementation-3-apache-arrow",children:["Implementation 3: ",(0,r.jsx)(n.a,{href:"https://arrow.apache.org/",children:"Apache Arrow"})]}),"\n",(0,r.jsx)(n.p,{children:"Apache Arrow is a universal memory format available in many languages."}),"\n",(0,r.jsxs)(n.p,{children:["The same function in ",(0,r.jsx)(n.code,{children:"arrow"})," would look like this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[pyfunction]\nfn create_list_arrow(py: Python, a: &PyAny) -> PyResult<Py<PyAny>> {\n    let arraydata = arrow::array::ArrayData::from_pyarrow(a).unwrap();\n\n    let buffer = arraydata.buffers()[0].as_slice();\n    let len = buffer.len();\n\n    // Zero Copy Buffer reference counted\n    let arc_s = Arc::new(buffer.to_vec());\n    let ptr = NonNull::new(arc_s.as_ptr() as *mut _).unwrap();\n    let raw_buffer = unsafe { arrow::buffer::Buffer::from_custom_allocation(ptr, len, arc_s) };\n    let output = arrow::array::ArrayData::try_new(\n        arrow::datatypes::DataType::UInt8,\n        len,\n        None,\n        0,\n        vec![raw_buffer],\n        vec![],\n    )\n    .unwrap();\n\n    output.to_pyarrow(py)\n}\n\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"-same-list-returns-in-33-milliseconds--thats-2x-better-than-pybytes-racehorseracehorse",children:["> Same list returns in ",(0,r.jsx)(n.strong,{children:"33 milliseconds"})," . That's ",(0,r.jsx)(n.strong,{children:"2x"})," better than ",(0,r.jsx)(n.code,{children:"PyBytes"})," ","\ud83d\udc0e","\ud83d\udc0e"]}),"\n",(0,r.jsx)(n.p,{children:"This is due to having zero copy when sending back the result. The zero-copying is safe because we are reference-counting the array. The array will be deallocating once all reference has been removed."}),"\n",(0,r.jsxs)(n.p,{children:["The benefits of ",(0,r.jsx)(n.code,{children:"arrow"})," is:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"to make zero-copy achievable, scaling better with bigger data."}),"\n",(0,r.jsx)(n.li,{children:"being reusable in other languages. We only have to replace the last line of the function with the export to the other languages."}),"\n",(0,r.jsxs)(n.li,{children:["having many types description including ",(0,r.jsx)(n.code,{children:"List"}),",",(0,r.jsx)(n.code,{children:"Mapping"})," and ",(0,r.jsx)(n.code,{children:"Struct"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["being directly usable in ",(0,r.jsx)(n.code,{children:"numpy"}),", ",(0,r.jsx)(n.code,{children:"pandas"}),", and ",(0,r.jsx)(n.code,{children:"pytorch"})," with zero-copy transmutation."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"debugging",children:"Debugging"}),"\n",(0,r.jsx)(n.p,{children:"Dealing with efficient Interface is not the only challenge of bridging multiple languages. We also have to deal with cross-language debugging."}),"\n",(0,r.jsx)(n.h3,{id:"unwrap",children:(0,r.jsx)(n.code,{children:".unwrap()"})}),"\n",(0,r.jsxs)(n.p,{children:["Our current implementation uses ",(0,r.jsx)(n.code,{children:".unwrap()"}),". However, this will panic the whole Python process if there is an error."]}),"\n",(0,r.jsx)(n.h4,{id:"-example-error",children:"> Example error:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"thread '<unnamed>' panicked at 'called `Result::unwrap()` on an `Err` value: PyErr { type: <class 'TypeError'>, value: TypeError('Expected instance of pyarrow.lib.Array, got builtins.int'), traceback: None }', src/lib.rs:45:62\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nTraceback (most recent call last):\n  File \"/home/peter/Documents/work/blogpost_ffi/test_script.py\", line 79, in <module>\n    array = blogpost_ffi.create_list_arrow(1)\npyo3_runtime.PanicException: called `Result::unwrap()` on an `Err` value: PyErr { type: <class 'TypeError'>, value: TypeError('Expected instance of pyarrow.lib.Array, got builtins.int'), traceback: None }\n"})}),"\n",(0,r.jsx)(n.h3,{id:"eyre",children:(0,r.jsx)(n.a,{href:"https://github.com/eyre-rs/eyre",children:"eyre"})}),"\n",(0,r.jsxs)(n.p,{children:["Eyre is an easy idiomatic error handling library for Rust applications. We can use eyre by wrapping our ",(0,r.jsx)(n.code,{children:"pyo3"})," project with the ",(0,r.jsx)(n.code,{children:"pyo3/eyre"})," feature flag, to replace all our ",(0,r.jsx)(n.code,{children:".unwrap()"})," with a ",(0,r.jsx)(n.code,{children:'.context("our context")?'}),". This will transform unrecoverable errors into recoverable Python errors while giving details about our errors."]}),"\n",(0,r.jsxs)(n.h4,{id:"-same-error-as-above-but-with-eyre-which-gives-a-better-looking-error-message",children:["> Same error as above but with ",(0,r.jsx)(n.code,{children:"eyre"})," which gives a better looking error message:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"Could not convert arrow data\n\nCaused by:\n    TypeError: Expected instance of pyarrow.lib.Array, got builtins.int\n\nLocation:\n    src/lib.rs:75:50\n"})}),"\n",(0,r.jsx)(n.p,{children:"Implementation details:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[pyfunction]\nfn create_list_arrow_eyre(py: Python, a: &PyAny) -> Result<Py<PyAny>> {\n    let arraydata =\n        arrow::array::ArrayData::from_pyarrow(a).context("Could not convert arrow data")?;\n\n    let buffer = arraydata.buffers()[0].as_slice();\n    let len = buffer.len();\n\n    // Zero Copy Buffer reference counted\n    let arc_s = Arc::new(buffer.to_vec());\n    let ptr = NonNull::new(arc_s.as_ptr() as *mut _).context("Could not create pointer")?;\n    let raw_buffer = unsafe { arrow::buffer::Buffer::from_custom_allocation(ptr, len, arc_s) };\n    let output = arrow::array::ArrayData::try_new(\n        arrow::datatypes::DataType::UInt8,\n        len,\n        None,\n        0,\n        vec![raw_buffer],\n        vec![],\n    )\n    .context("could not create arrow arraydata")?;\n\n    output\n        .to_pyarrow(py)\n        .context("Could not convert to pyarrow")\n}\n\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"python-traceback-with-eyre",children:["Python traceback with ",(0,r.jsx)(n.code,{children:"eyre"})]}),"\n",(0,r.jsx)(n.p,{children:"I will mention that you might lose the Python traceback error when calling Python code from a Rust code."}),"\n",(0,r.jsx)(n.p,{children:"I recommend using the following custom traceback method to have a descriptive error:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[pyfunction]\nfn call_func_eyre(py: Python, func: Py<PyAny>) -> Result<()> {    \n    let _call_python = func.call0(py).context("function called failed")?;\n    Ok(())\n}\n\nfn traceback(err: pyo3::PyErr) -> eyre::Report {\n    let traceback = Python::with_gil(|py| err.traceback(py).and_then(|t| t.format().ok()));\n    if let Some(traceback) = traceback {\n        eyre::eyre!("{traceback}\\n{err}")\n    } else {\n        eyre::eyre!("{err}")\n    }\n}\n\n#[pyfunction]\nfn call_func_eyre_traceback(py: Python, func: Py<PyAny>) -> Result<()> {\n    let _call_python = func\n        .call0(py)\n        .map_err(traceback) // this will gives python traceback.\n        .context("function called failed")?;\n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"-example-error-with-no-custom-traceback",children:"> Example error with no custom traceback:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"---Eyre no traceback---\neyre no traceback says: function called failed\n\nCaused by:\n    AssertionError: I have no idea what is wrong\n\nLocation:\n    src/lib.rs:89:39\n------\n"})}),"\n",(0,r.jsx)(n.h4,{id:"-better-errors-with-custom-traceback",children:"> Better errors with custom traceback:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'---Eyre traceback---\neyre traceback says: function called failed\n\nCaused by:\n    Traceback (most recent call last):\n      File "/home/peter/Documents/work/blogpost_ffi/test_script.py", line 96, in abc\n        assert False, "I have no idea what is wrong"\n\n    AssertionError: I have no idea what is wrong\n\nLocation:\n    src/lib.rs:96:9\n------\n'})}),"\n",(0,r.jsx)(n.p,{children:"With the traceback, we can quickly identify the root error."}),"\n",(0,r.jsx)(n.h2,{id:"memory-management",children:"Memory management"}),"\n",(0,r.jsx)(n.p,{children:"Let's take another example, and imagine that we need to create arrays within a loop:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"/// Unbounded memory growth\n#[pyfunction]\nfn unbounded_memory_growth(py: Python) -> Result<()> {\n    for _ in 0..10 {\n        let a: Vec<u8> = vec![0; 40_000_000];\n        let _ = PyBytes::new(py, &a);`\n        \n        std::thread::sleep(Duration::from_secs(1));\n    }\n\n    Ok(())\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"-calling-this-function-will-consume-440mb-of-memory--1",children:["> Calling this function will consume 440MB of memory. ","\ud83d\udc4e"]}),"\n",(0,r.jsxs)(n.p,{children:["What happened is that ",(0,r.jsx)(n.code,{children:"pyo3"})," memory model keeps all Python variables in memory until the GIL is released."]}),"\n",(0,r.jsxs)(n.p,{children:["Therefore, if we create variables in a ",(0,r.jsx)(n.code,{children:"pyfunction"})," loop, all temporary variables are going to be kept until the GIL is released."]}),"\n",(0,r.jsxs)(n.p,{children:["This is due to ",(0,r.jsx)(n.code,{children:"pyfunction"})," locking the GIL by default."]}),"\n",(0,r.jsx)(n.p,{children:"By understanding the GIL-based memory model, we can use a scoped GIL to have the expected behaviour:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[pyfunction]\nfn bounded_memory_growth(py: Python) -> Result<()> {\n    py.allow_threads(|| {\n        for _ in 0..10 {\n            Python::with_gil(|py| {\n                let a: Vec<u8> = vec![0; 40_000_000];\n                let _bytes = PyBytes::new(py, &a);\n            \n                std::thread::sleep(Duration::from_secs(1));\n            });\n        }\n    });\n\n    // or\n    \n    for _ in 0..10 {\n        let pool = unsafe { py.new_pool() };\n        let py = pool.python();\n\n        let a: Vec<u8> = vec![0; 40_000_000];\n        let _bytes = PyBytes::new(py, &a);\n\n        std::thread::sleep(Duration::from_secs(1));\n    }\n\n    Ok(())\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"-calling-this-function-will-consume-80mb-of-memory-thumbsup",children:"> Calling this function will consume 80MB of memory. :thumbsup:"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://pyo3.rs/main/memory.html#gil-bound-memory",children:"More info can be found here"})}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://github.com/PyO3/pyo3/issues/3382",children:"Possible fix in Pyo3 0.21!"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"race-condition",children:"Race condition"}),"\n",(0,r.jsx)(n.p,{children:"Let's take another example, and imagine that we need to process data in different threads:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'/// Function GIL Lock\n#[pyfunction]\nfn gil_lock() {\n    let start_time = Instant::now();\n    std::thread::spawn(move || {\n        Python::with_gil(|py| println!("This threaded print was printed after {:#?}", &start_time.elapsed()));\n    });\n\n    std::thread::sleep(Duration::from_secs(10));\n}\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"-this-threaded-print-was-printed-after-100s-cry",children:["> This threaded print was printed after 10.0s. ","\ud83d\ude22"]}),"\n",(0,r.jsxs)(n.p,{children:["When using Python with ",(0,r.jsx)(n.code,{children:"pyo3"}),", we have to make sure to know exactly when the GIL is locked or unlocked to avoid race conditions."]}),"\n",(0,r.jsxs)(n.p,{children:["In the example above, the issue is that by default ",(0,r.jsx)(n.code,{children:"pyo3"})," is going to lock the GIL in the main function thread, therefore blocking the spawned thread that is waiting for the GIL."]}),"\n",(0,r.jsx)(n.p,{children:"If we use the GIL in the main function thread or release the GIL in the main function thread, there is no issue."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'/// No gil lock\n#[pyfunction]\nfn gil_unlock() {\n    let start_time = Instant::now();\n    std::thread::spawn(move || {\n        std::thread::sleep(Duration::from_secs(10));\n    });\n\n    Python::with_gil(|py| println!("1. This was printed after {:#?}", &start_time.elapsed()));\n\n    // or\n\n    let start_time = Instant::now();\n    std::thread::spawn(move || {\n        Python::with_gil(|py| println!("2. This was printed after {:#?}", &start_time.elapsed()));\n    });\n    Python::with_gil(|py| {\n        py.allow_threads(|| {\n            std::thread::sleep(Duration::from_secs(10));\n        })\n    });\n}\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"-1-was-printed-after-32\xb5s-and-2-was-printed-after-80\xb5s-so-there-was-no-race-condition-smile",children:['> "1" was printed after 32\xb5s and "2" was printed after 80\xb5s, so there was no race condition. ',"\ud83d\ude04"]}),"\n",(0,r.jsx)(n.h2,{id:"tracing",children:"Tracing"}),"\n",(0,r.jsx)(n.p,{children:"As we can see, being able to measure the time spent when interfacing can be very valuable to identify bottlenecks."}),"\n",(0,r.jsx)(n.p,{children:"But measuring the time spent manually as we did before can be tedious."}),"\n",(0,r.jsxs)(n.p,{children:["What we can do is use a tracing library to do it for us. ",(0,r.jsx)(n.a,{href:"https://opentelemetry.io/",children:"Opentelemetry"})," can help us build a distributed observable system capable of bridging multiple languages. ",(0,r.jsx)(n.a,{href:"https://opentelemetry.io/",children:"Opentelemetry"})," can be used for tracing, metrics and logs."]}),"\n",(0,r.jsx)(n.p,{children:"For example, if we add:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'/// No gil lock\n#[pyfunction]\nfn global_tracing(py: Python, func: Py<PyAny>) {\n    // global::set_text_map_propagator(opentelemetry_jaeger::Propagator::new());\n    global::set_text_map_propagator(TraceContextPropagator::new());\n\n    // Connect to Jaeger Opentelemetry endpoint\n    // Start a new endpoint with:\n    // docker run -d -p6831:6831/udp -p6832:6832/udp -p16686:16686 jaegertracing/all-in-one:latest\n    let _tracer = opentelemetry_jaeger::new_agent_pipeline()\n        .with_endpoint("172.17.0.1:6831")\n        .with_service_name("rust_ffi")\n        .install_simple()\n        .unwrap();\n\n    let tracer = global::tracer("test");\n\n    // Parent Trace, first trace\n    let _ = tracer.in_span("parent_python_work", |cx| -> Result<()> { \n        std::thread::sleep(Duration::from_secs(1));\n        \n        let mut map = HashMap::new();\n        global::get_text_map_propagator(|propagator| propagator.inject_context(&cx, &mut map));\n\n        let output = func\n            .call1(py, (map,))\n            .map_err(traceback)\n            .context("function called failed")?;\n        let out_map: HashMap<String, String> = output.extract(py).unwrap();\n        let out_context = global::get_text_map_propagator(|prop| prop.extract(&out_map));\n\n        std::thread::sleep(Duration::from_secs(1));\n\n        let _span = tracer.start_with_context("after_python_work", &out_context); // third trace\n\n        Ok(())\n    });\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"And the following, in the Python code:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def abc(cx):\n    propagator = TraceContextTextMapPropagator()\n    context = propagator.extract(carrier=cx)\n\n    with tracing.tracer.start_as_current_span(\n        name="Python_span", context=context\n    ) as child_span:\n        child_span.add_event("in Python!")\n        output = {}\n        tracing.propagator.inject(output)\n        time.sleep(2)\n    return output\n'})}),"\n",(0,r.jsx)(n.p,{children:"We will get the following traces:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(69687).A+"",width:"3944",height:"1551"})}),"\n",(0,r.jsx)(n.p,{children:"Using this we can measure the time spent when interfacing languages, identify lock issues, and with the combination of logs and metrics, reduce the complexity of multi-language libraries."}),"\n",(0,r.jsx)(n.h1,{id:"dora-rs",children:(0,r.jsx)(n.a,{href:"https://github.com/dora-rs/dora",children:"dora-rs"})}),"\n",(0,r.jsx)(n.p,{children:"Hopefully, this small blog post should help you identify FFI issues."}),"\n",(0,r.jsxs)(n.p,{children:["All optimization above have already been implemented within ",(0,r.jsx)(n.a,{href:"https://github.com/dora-rs/dora",children:"dora-rs"})," that lets you build fast and simple dataflows using Rust, Python, C and C++."]}),"\n",(0,r.jsxs)(n.p,{children:["You're very welcome to check out ",(0,r.jsx)(n.a,{href:"https://github.com/dora-rs/dora",children:"dora-rs"})," if bridging languages in a dataflow is your usecase."]}),"\n",(0,r.jsxs)(n.p,{children:["We just recently opened a Discord and you can reach out there for literally any question, even just for a quick chat: ",(0,r.jsx)(n.a,{href:"https://discord.gg/DXJ6edAtym",children:"https://discord.gg/DXJ6edAtym"})]}),"\n",(0,r.jsxs)(n.p,{children:["I'm also going to present this FFI work at ",(0,r.jsx)(n.a,{href:"https://workshop2023.gosim.org/schedule#auto",children:"GOSIM Workshop in Shanghai on the 23rd of Sept 2023"}),"!"]}),"\n",(0,r.jsxs)(n.p,{children:["For more info on ",(0,r.jsx)(n.code,{children:"dora-rs"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Github: ",(0,r.jsx)(n.a,{href:"https://github.com/dora-rs/dora",children:"https://github.com/dora-rs/dora"})]}),"\n",(0,r.jsxs)(n.li,{children:["Website: ",(0,r.jsx)(n.a,{href:"https://www.dora-rs.ai/",children:"https://www.dora-rs.ai/"})]}),"\n",(0,r.jsxs)(n.li,{children:["Discord: ",(0,r.jsx)(n.a,{href:"https://discord.gg/XqhQaN8P",children:"https://discord.gg/XqhQaN8P"})]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},69687:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/blogpost_ffi-a663a0fdaf6f3a9acc323b2c364d01aa.png"},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var r=t(96540);const a={},s=r.createContext(a);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);