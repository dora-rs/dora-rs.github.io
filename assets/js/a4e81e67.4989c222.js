"use strict";(self.webpackChunkdora_rs_github_io=self.webpackChunkdora_rs_github_io||[]).push([[3400],{52823:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>p});var o=t(74848),r=t(28453);const s={},i="PID Control operator",a={id:"nodes_operators/pid_control_op",title:"PID Control operator",description:"pid control operator computes the command that needs to be executed to follow the given waypoints.",source:"@site/docs/nodes_operators/pid_control_op.md",sourceDirName:"nodes_operators",slug:"/nodes_operators/pid_control_op",permalink:"/docs/nodes_operators/pid_control_op",draft:!1,unlisted:!1,editUrl:"https://github.com/dora-rs/dora-rs.github.io/edit/main/docs/nodes_operators/pid_control_op.md",tags:[],version:"current",frontMatter:{}},d={},p=[{value:"Inputs",id:"inputs",level:2},{value:"Outputs",id:"outputs",level:2},{value:"Graph Description",id:"graph-description",level:2},{value:"Graph Viz",id:"graph-viz",level:2},{value:"Hyperparameters consider changing",id:"hyperparameters-consider-changing",level:2},{value:"Methods",id:"methods",level:2},{value:"<code>__init__()</code>",id:"__init__",level:3},{value:"<code>.on_event(...)</code>",id:"on_event",level:3},{value:"<code>.on_input(...)</code>",id:"on_input",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"pid-control-operator",children:"PID Control operator"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"pid"})," control operator computes the command that needs to be executed to follow the given waypoints.\nIt reacts to the car current speed and position in a way that accelerates or brake according to previous inputs."]}),"\n",(0,o.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"waypoints coordinates to follow."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"outputs",children:"Outputs"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"throttle, steering (rad) and braking."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"graph-description",children:"Graph Description"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"  - id: pid_control_op\n    operator:\n      python: ../../operators/pid_control_op.py\n      outputs:\n        - control\n      inputs:\n        position: oasis_agent/position\n        speed: oasis_agent/speed\n        waypoints: fot_op/waypoints\n"})}),"\n",(0,o.jsx)(n.h2,{id:"graph-viz",children:"Graph Viz"}),"\n",(0,o.jsx)(n.mermaid,{value:"        flowchart TB\n  oasis_agent\nsubgraph fot_op\n  fot_op/op[op]\nend\nsubgraph pid_control_op\n  pid_control_op/op[op]\nend\n  oasis_agent -- position --\x3e pid_control_op/op\n  oasis_agent -- speed --\x3e pid_control_op/op\n  fot_op/op -- waypoints --\x3e pid_control_op/op\n  pid_control_op/op -- control --\x3e oasis_agent"}),"\n",(0,o.jsx)(n.h2,{id:"hyperparameters-consider-changing",children:"Hyperparameters consider changing"}),"\n",(0,o.jsxs)(n.p,{children:["See: ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/PID_controller",children:"https://en.wikipedia.org/wiki/PID_controller"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"pid_p = 0.1\npid_d = 0.0\npid_i = 0.05\ndt = 1.0 / 20   \n"})}),"\n",(0,o.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,o.jsx)(n.h3,{id:"__init__",children:(0,o.jsx)(n.code,{children:"__init__()"})}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Source Code"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"    def __init__(self):\n        self.waypoints = []\n        self.target_speeds = []\n        self.metadata = {}\n        self.position = []\n        self.speed = []\n        self.previous_position = []\n        self.current_speed = []\n        self.previous_time = time.time()\n\n\n"})})]}),"\n",(0,o.jsx)(n.h3,{id:"on_event",children:(0,o.jsx)(n.code,{children:".on_event(...)"})}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Source Code"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'\n    def on_event(\n        self,\n        dora_event: dict,\n        send_output: Callable[[str, bytes], None],\n    ) -> DoraStatus:\n        if dora_event["type"] == "INPUT":\n            return self.on_input(dora_event, send_output)\n        return DoraStatus.CONTINUE\n\n\n'})})]}),"\n",(0,o.jsx)(n.h3,{id:"on_input",children:(0,o.jsx)(n.code,{children:".on_input(...)"})}),"\n",(0,o.jsx)(n.p,{children:'Handle input.\nArgs:\ndora_input["id"]  (str): Id of the input declared in the yaml configuration\ndora_input["value"] (arrow.array(UInt8)): Bytes message of the input\nsend_output (Callable[[str, bytes]]): Function enabling sending output back to dora.'}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Source Code"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'\n    def on_input(\n        self,\n        dora_input: dict,\n        send_output: Callable[[str, bytes], None],\n    ):\n        """Handle input.\n        Args:\n            dora_input["id"]  (str): Id of the input declared in the yaml configuration\n            dora_input["value"] (arrow.array(UInt8)): Bytes message of the input\n            send_output (Callable[[str, bytes]]): Function enabling sending output back to dora.\n        """\n\n        if "position" == dora_input["id"]:\n            self.position = dora_input["value"].to_numpy()\n            return DoraStatus.CONTINUE\n\n        elif dora_input["id"] == "speed":\n            self.speed = np.array(dora_input["value"])\n            return DoraStatus.CONTINUE\n\n        elif "waypoints" == dora_input["id"]:\n            waypoints = dora_input["value"].to_numpy()\n            waypoints = waypoints.reshape((-1, 3))\n\n            self.target_speeds = waypoints[:, 2]\n            self.waypoints = waypoints[:, :2]\n            self.metadata = dora_input["metadata"]\n\n        if len(self.position) == 0 or len(self.speed) == 0:\n            return DoraStatus.CONTINUE\n\n        if len(self.waypoints) == 0:\n            send_output(\n                "control",\n                pa.array(np.array([0, 0, 1], np.float16).ravel()),\n                self.metadata,\n            )\n            return DoraStatus.CONTINUE\n\n        [x, y, _, rx, ry, rz, rw] = self.position\n        [_, _, yaw] = R.from_quat([rx, ry, rz, rw]).as_euler("xyz", degrees=False)\n        distances = pairwise_distances(self.waypoints, np.array([[x, y]])).T[0]\n\n        index = distances > MIN_PID_WAYPOINT_DISTANCE\n        self.waypoints = self.waypoints[index]\n        self.target_speeds = self.target_speeds[index]\n        distances = distances[index]\n\n        if len(self.waypoints) == 0:\n            target_angle = 0\n            target_speed = 0\n        else:\n            argmin_distance = np.argmin(distances)\n\n            ## Retrieve the closest point to the steer distance\n            target_location = self.waypoints[argmin_distance]\n\n            target_speed = self.target_speeds[argmin_distance]\n\n            ## Compute the angle of steering\n            target_vector = target_location - [x, y]\n\n            target_angle = get_angle(\n                math.atan2(target_vector[1], target_vector[0]), yaw\n            )\n\n        throttle, brake = compute_throttle_and_brake(\n            pid, LA.norm(self.speed), target_speed\n        )\n\n        send_output(\n            "control",\n            pa.array(np.array([throttle, target_angle, brake], np.float16)),\n            self.metadata,\n        )\n        return DoraStatus.CONTINUE\n\n\n'})})]})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var o=t(96540);const r={},s=o.createContext(r);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);