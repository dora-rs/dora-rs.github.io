"use strict";(self.webpackChunkdora_rs_github_io=self.webpackChunkdora_rs_github_io||[]).push([[5982],{71177:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>p,contentTitle:()=>i,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var s=t(74848),o=t(28453);const a={},i="FOT operator",r={id:"nodes_operators/fot_op",title:"FOT operator",description:"The Frenet Optimal Planner Operator is based on https://github.com/erdos-project/frenetoptimaltrajectoryplanner/ and wrap the different elements obstacles, position, speed ... into a frenet consumable format.",source:"@site/docs/nodes_operators/fot_op.md",sourceDirName:"nodes_operators",slug:"/nodes_operators/fot_op",permalink:"/docs/nodes_operators/fot_op",draft:!1,unlisted:!1,editUrl:"https://github.com/dora-rs/dora-rs.github.io/edit/main/docs/nodes_operators/fot_op.md",tags:[],version:"current",frontMatter:{}},p={},l=[{value:"Inputs",id:"inputs",level:2},{value:"Outputs",id:"outputs",level:2},{value:"Example Image",id:"example-image",level:2},{value:"Graph Description",id:"graph-description",level:2},{value:"Graph Viz",id:"graph-viz",level:2},{value:"Methods",id:"methods",level:2},{value:"<code>__init__()</code>",id:"__init__",level:3},{value:"<code>.on_event(...)</code>",id:"on_event",level:3},{value:"<code>.on_input(...)</code>",id:"on_input",level:3}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",mermaid:"mermaid",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...n.components},{Details:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{id:"fot-operator",children:"FOT operator"}),"\n",(0,s.jsxs)(e.p,{children:["The Frenet Optimal Planner Operator is based on ",(0,s.jsx)(e.a,{href:"https://github.com/erdos-project/frenet_optimal_trajectory_planner/",children:"https://github.com/erdos-project/frenet_optimal_trajectory_planner/"})," and wrap the different elements ",(0,s.jsx)(e.code,{children:"obstacles"}),", ",(0,s.jsx)(e.code,{children:"position"}),", ",(0,s.jsx)(e.code,{children:"speed"})," ... into a frenet consumable format."]}),"\n",(0,s.jsx)(e.p,{children:"FOT inputs are:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'initial_conditions = {\n    "ps": 0,\n    "target_speed": # The target speed\n    "pos": # The x, y current position\n    "vel": # The vx, vy current speed\n    "wp": # [[x, y], ... n_waypoints ] desired waypoints\n    "obs": # [[min_x, min_y, max_x, max_y], ... ] obstacles on the way\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"There is also a set of hyperparameters that are described below."}),"\n",(0,s.jsxs)(e.p,{children:["As our obstacles are defined as 3D dot we need to transform those dot into ",(0,s.jsx)(e.code,{children:"[min_x, min_y, max_x, max_y]"})," format. We do that within the ",(0,s.jsx)(e.code,{children:"get_obstacle_list"})," function. This approximation is very basic and probably need to be revisited."]}),"\n",(0,s.jsx)(e.p,{children:"The output is either a successful trajectory that we can feed into PID. Or it is a failure in which case we send the current position as waypoint."}),"\n",(0,s.jsx)(e.h2,{id:"inputs",children:"Inputs"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"image: HEIGHT x WIDTH x BGR array."}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"outputs",children:"Outputs"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"waypoints: x_points, y_points, speeds"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"example-image",children:"Example Image"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"https://i.imgur.com/9AGDlQY.gif",alt:"Imgur"})}),"\n",(0,s.jsx)(e.h2,{id:"graph-description",children:"Graph Description"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"  - id: fot_op\n    operator:\n      python: ../../operators/fot_op.py\n      outputs:\n        - waypoints\n      inputs:\n        position: oasis_agent/position\n        speed: oasis_agent/speed\n        obstacles: obstacle_location_op/obstacles\n        gps_waypoints: carla_gps_op/gps_waypoints\n"})}),"\n",(0,s.jsx)(e.h2,{id:"graph-viz",children:"Graph Viz"}),"\n",(0,s.jsx)(e.mermaid,{value:"        flowchart TB\n  oasis_agent\nsubgraph carla_gps_op\n  carla_gps_op/op[op]\nend\nsubgraph fot_op\n  fot_op/op[op]\nend\nsubgraph obstacle_location_op\n  obstacle_location_op/op[op]\nend\nsubgraph pid_control_op\n  pid_control_op/op[op]\nend\n  carla_gps_op/op -- gps_waypoints --\x3e fot_op/op\n  obstacle_location_op/op -- obstacles --\x3e fot_op/op\n  oasis_agent -- position --\x3e fot_op/op\n  oasis_agent -- speed --\x3e fot_op/op\n  fot_op/op -- waypoints --\x3e pid_control_op/op"}),"\n",(0,s.jsx)(e.h2,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(e.h3,{id:"__init__",children:(0,s.jsx)(e.code,{children:"__init__()"})}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Source Code"}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'    def __init__(self):\n        self.obstacles = np.array([])\n        self.lanes = np.array([])\n        self.position = []\n        self.speed = []\n        self.last_position = []\n        self.waypoints = []\n        self.gps_waypoints = np.array([])\n        self.last_obstacles = np.array([])\n        self.obstacle_metadata = {}\n        self.gps_metadata = {}\n        self.metadata = {}\n        self.orientation = None\n        self.outputs = []\n        self.hyperparameters = {\n            "max_speed": 25.0,\n            "max_accel": 45.0,\n            "max_curvature": 55.0,\n            "max_road_width_l": 0.1,\n            "max_road_width_r": 0.1,\n            "d_road_w": 0.5,\n            "dt": 0.5,\n            "maxt": 5.0,\n            "mint": 2.0,\n            "d_t_s": 5,\n            "n_s_sample": 2.0,\n            "obstacle_clearance": 0.1,\n            "kd": 1.0,\n            "kv": 0.1,\n            "ka": 0.1,\n            "kj": 0.1,\n            "kt": 0.1,\n            "ko": 0.1,\n            "klat": 1.0,\n            "klon": 1.0,\n            "num_threads": 0,  # set 0 to avoid using threaded algorithm\n        }\n        self.conds = {\n            "s0": 0,\n            "target_speed": TARGET_SPEED,\n        }  # paste output from debug log\n\n\n'})})]}),"\n",(0,s.jsx)(e.h3,{id:"on_event",children:(0,s.jsx)(e.code,{children:".on_event(...)"})}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Source Code"}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'\n    def on_event(\n        self,\n        dora_event: dict,\n        send_output: Callable[[str, bytes], None],\n    ) -> DoraStatus:\n        if dora_event["type"] == "INPUT":\n            return self.on_input(dora_event, send_output)\n        return DoraStatus.CONTINUE\n\n\n'})})]}),"\n",(0,s.jsx)(e.h3,{id:"on_input",children:(0,s.jsx)(e.code,{children:".on_input(...)"})}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Source Code"}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'\n    def on_input(\n        self,\n        dora_input: dict,\n        send_output: Callable[[str, bytes], None],\n    ):\n        if dora_input["id"] == "position":\n            self.last_position = self.position\n            self.position = np.array(dora_input["value"])\n            if len(self.last_position) == 0:\n                self.last_position = self.position\n            return DoraStatus.CONTINUE\n\n        elif dora_input["id"] == "speed":\n            self.speed = np.array(dora_input["value"])\n            return DoraStatus.CONTINUE\n\n        elif dora_input["id"] == "obstacles":\n            obstacles = np.array(dora_input["value"]).reshape((-1, 5))\n            if len(self.last_obstacles) > 0:\n                self.obstacles = np.concatenate([self.last_obstacles, obstacles])\n            else:\n                self.obstacles = obstacles\n\n        elif dora_input["id"] == "global_lanes":\n            lanes = np.array(dora_input["value"]).reshape((-1, 60, 3))\n            self.lanes = lanes\n            return DoraStatus.CONTINUE\n\n        elif "gps_waypoints" == dora_input["id"]:\n            waypoints = np.array(dora_input["value"])\n            waypoints = waypoints.reshape((-1, 3))[:, :2]\n            self.gps_waypoints = waypoints\n            return DoraStatus.CONTINUE\n\n        if len(self.gps_waypoints) == 0:\n            print("No waypoints")\n            send_output(\n                "waypoints",\n                self.gps_waypoints.tobytes(),\n                dora_input["metadata"],\n            )\n            return DoraStatus.CONTINUE\n\n        elif len(self.position) == 0 or len(self.speed) == 0:\n            return DoraStatus.CONTINUE\n\n        [x, y, z, rx, ry, rz, rw] = self.position\n        [_, _, yaw] = R.from_quat([rx, ry, rz, rw]).as_euler("xyz", degrees=False)\n\n        gps_obstacles = get_obstacle_list(\n            self.position, self.obstacles, self.gps_waypoints\n        )\n\n        if len(self.lanes) > 0:\n            lanes = get_lane_list(self.position, self.lanes, self.gps_waypoints)\n            obstacles = np.concatenate([gps_obstacles, lanes])\n        else:\n            obstacles = gps_obstacles\n        initial_conditions = {\n            "ps": 0,\n            "target_speed": self.conds["target_speed"],\n            "pos": self.position[:2],\n            "vel": (np.clip(LA.norm(self.speed), 0.5, 40))\n            * np.array([np.cos(yaw), np.sin(yaw)]),\n            "wp": self.gps_waypoints,\n            "obs": obstacles,\n        }\n\n        (\n            result_x,\n            result_y,\n            speeds,\n            ix,\n            iy,\n            iyaw,\n            d,\n            s,\n            speeds_x,\n            speeds_y,\n            misc,\n            costs,\n            success,\n        ) = fot_wrapper.run_fot(initial_conditions, self.hyperparameters)\n\n        if not success:\n            initial_conditions["wp"] = initial_conditions["wp"][:5]\n            print(f"fot failed. stopping with {initial_conditions}.")\n            target_distance = LA.norm(self.gps_waypoints[-1] - self.position[:2])\n            print(f"Distance to target: {target_distance}")\n            for obstacle in self.obstacles:\n                print(f"obstacles:{obstacle}, label: {LABELS[int(obstacle[-1])]}")\n\n            send_output(\n                "waypoints",\n                pa.array(np.array([x, y, 0.0], np.float32)),\n                dora_input["metadata"],\n            )\n            return DoraStatus.CONTINUE\n\n        self.waypoints = np.concatenate([result_x, result_y]).reshape((2, -1)).T\n\n        self.outputs = np.ascontiguousarray(\n            np.concatenate([result_x, result_y, speeds])\n            .reshape((3, -1))\n            .T.astype(np.float32)\n        )\n        send_output(\n            "waypoints",\n            pa.array(self.outputs.ravel()),\n            dora_input["metadata"],\n        )\n        return DoraStatus.CONTINUE\n\n\n'})})]})]})}function c(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},28453:(n,e,t)=>{t.d(e,{R:()=>i,x:()=>r});var s=t(96540);const o={},a=s.createContext(o);function i(n){const e=s.useContext(a);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:i(n.components),s.createElement(a.Provider,{value:e},n.children)}}}]);